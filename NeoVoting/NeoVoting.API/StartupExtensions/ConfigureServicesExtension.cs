using FluentValidation;
using FluentValidation.AspNetCore;
using MicroElements.Swashbuckle.FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using NeoVoting.Application.Exceptions;
using NeoVoting.Application.Services;
using NeoVoting.Application.ServicesContracts;
using NeoVoting.Application.Validators;
using NeoVoting.Domain.Contracts;
using NeoVoting.Domain.IdentityEntities;
using NeoVoting.Domain.RepositoryContracts;
using NeoVoting.Infrastructure.DbContext;
using NeoVoting.Infrastructure.Repositories;
using System.Text;

namespace NeoVoting.API.StartupExtensions
{
    public static class ConfigureServicesExtension
    {
        public static IServiceCollection ConfigureServices(this IServiceCollection services,
            IConfiguration configuration, ConfigureHostBuilder configureHostBuilder)
        {
            services.AddHttpContextAccessor();

            //CONNECTION STRING SETUP
            var connectionString = configuration.GetConnectionString("DefaultConnection")
                ?? throw new InvalidOperationException
                ("Connection string 'DefaultConnection' not found.");

            services.AddDbContext<ApplicationDbContext>(options =>
            {
                options.UseSqlServer(connectionString);
            });



            //IDENTITY SETUP
            services.AddIdentity<ApplicationUser, ApplicationRole>(options =>
            {
                options.Password.RequireDigit = false;
                options.Password.RequireLowercase = false;
                options.Password.RequireUppercase = false;
                options.Password.RequireNonAlphanumeric = false; // Set to false if you want to allow only letters and digits
                options.Password.RequiredLength = 3;
                options.Password.RequiredUniqueChars = 1; // You can increase for stricter policy
                options.Lockout.AllowedForNewUsers = true;
                options.Lockout.MaxFailedAccessAttempts = 5;        // ← how many times
                options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(15); // lock duration
            })

               .AddEntityFrameworkStores<ApplicationDbContext>()

               .AddDefaultTokenProviders()

               ;

            // The two lines below are unnecessary. The `.AddEntityFrameworkStores<TContext>()`
            // call you made above ALREADY registers these for you.
            // You are explicitly re-registering the exact same default implementations.
            /*
               .AddUserStore<UserStore
               <ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
               //Repository for Users generated by EF automatically
               .AddRoleStore<RoleStore
               <ApplicationRole, ApplicationDbContext, Guid>>()
               ;
            */


            //JWT AUTHENTICATION SETUP
            //Configure Authentication
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            })
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = configuration["JwtSettings:Issuer"],
                    ValidAudience = configuration["JwtSettings:Audience"],
                    IssuerSigningKey = new SymmetricSecurityKey(
                        Encoding.UTF8.GetBytes(configuration["JwtSettings:Key"]!))
                };

                options.Events = new JwtBearerEvents
                {
                    // Handle 401 Unauthorized (Token invalid or missing)
                    OnChallenge = async context =>
                    {
                        // Skip the default logic
                        context.HandleResponse();

                        context.Response.StatusCode = StatusCodes.Status401Unauthorized;
                        context.Response.ContentType = "application/problem+json";

                        var problem = new ProblemDetails
                        {
                            Type = "https://tools.ietf.org/html/rfc7235#section-3.1",
                            Title = "Unauthorized",
                            Status = StatusCodes.Status401Unauthorized,
                            Detail = "Authentication failed. Token is missing, invalid, or expired.",
                            Instance = context.Request.Path
                        };

                        await context.Response.WriteAsJsonAsync(problem);
                    },

                    // Handle 403 Forbidden (Token valid, but Role/Policy failed)
                    OnForbidden = async context =>
                    {
                        context.Response.StatusCode = StatusCodes.Status403Forbidden;
                        context.Response.ContentType = "application/problem+json";

                        var problem = new ProblemDetails
                        {
                            Type = "https://tools.ietf.org/html/rfc7231#section-6.5.3",
                            Title = "Forbidden",
                            Status = StatusCodes.Status403Forbidden,
                            Detail = "You do not have permission to access this resource.",
                            Instance = context.Request.Path
                        };

                        await context.Response.WriteAsJsonAsync(problem);
                    }
                };
            });

            //CORS SETUP
            //(Crucial if your frontend is on a different port, e.g., React/Angular)
            //services.AddCors(options =>
            //{
            //    options.AddPolicy("FrontendPolicy", policy =>
            //    {
            //        policy.WithOrigins("http://localhost:3000") // Your Frontend URL
            //              .AllowAnyMethod()
            //              .AllowAnyHeader()
            //              .AllowCredentials(); // <--- REQUIRED for Cookies to be sent/received
            //    });
            //});




            //WEB API SERVICES SETUP
            services.AddControllers();
            services.AddEndpointsApiExplorer();

            // Register your Custom Handler
            services.AddExceptionHandler<GlobalExceptionHandler>();

            services.AddProblemDetails(); // Required for .NET 8 Exception Handler to work


            // =========================================================================
            // SWAGGER CONFIGURATION START
            // =========================================================================
            services.AddSwaggerGen(options =>
            {
                options.SwaggerDoc("v1", new OpenApiInfo
                {
                    Title = "NeoVoting API",
                    Version = "v1",
                    Description = "API for the NeoVoting System"
                });

                // 1. Define the Security Scheme (The "Padlock" definition)
                options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
                {
                    Name = "Authorization",
                    Description = "Enter the JWT token directly. \r\n\r\nExample: `eyJhbGciOiJIUzI1Ni...`",
                    In = ParameterLocation.Header,
                    Type = SecuritySchemeType.Http, // Use Http for standard Bearer auth
                    Scheme = "Bearer",
                    BearerFormat = "JWT"
                });

                // 2. Define the Security Requirement (Apply the lock to endpoints)
                options.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer" // Must match the name defined above
                }
            },
            Array.Empty<string>() // Scopes (leave empty for standard JWT)
        }
    });
            });
            // =========================================================================
            // SWAGGER CONFIGURATION END
            // =========================================================================



            //HTTP CLIENT SETUP FOR EXTERNAL GOVERNMENT SYSTEM API

            services.AddHttpClient<IGovernmentSystemGateway, GovernmentSystemGateway>(client =>
            {
                var baseUrl = configuration["GovernmentSystem:BaseUrl"]
                              ?? throw new Exception("GovernmentSystem:BaseUrl is missing");

                client.BaseAddress = new Uri(baseUrl);

                var apiKey = configuration["GovernmentSystem:ApiKey"]
                             ?? throw new Exception("GovernmentSystem:ApiKey is missing");

                client.DefaultRequestHeaders.Add("X-Gov-Api-Key", apiKey);
            });

           
            

            // --- REGISTER THE UNIT OF WORK ---
            // We use AddScoped for the lifetime. This means a single instance of UnitOfWork
            // (and therefore ApplicationDbContext) is created for each HTTP request. This is the standard.
            services.AddScoped<IUnitOfWork, UnitOfWork>();

            // --- REGISTER REPOSITORIES ---

            services.AddScoped<ICandidateProfileRepository, CandidateProfileRepository>();
            services.AddScoped<IElectionRepository, ElectionRepository>();
            services.AddScoped<IElectionStatusRepository, ElectionStatusRepository>();
            services.AddScoped<IElectionWinnerRepository, ElectionWinnerRepository>();
            services.AddScoped<IGovernorateRepository, GovernorateRepository>();
            services.AddScoped<IPublicVoteLogRepository, PublicVoteLogRepository>();
            services.AddScoped<ISystemAuditLogRepository, SystemAuditLogRepository>();
            services.AddScoped<IVoteChoiceRepository, VoteChoiceRepository>();
            services.AddScoped<IVoteRepository, VoteRepository>();
            services.AddScoped<IApplicationUserRepository, ApplicationUserRepository>();

            // --- REGISTER SERVICES --- 

            services.AddScoped<ICurrentUserServices, CurrentUserServices>();
            services.AddScoped<IAuthServices, AuthServices>();
            services.AddScoped<ITokenServices, TokenServices>();


            //FLUENT VALIDATION SETUP
            services.AddFluentValidationAutoValidation();
            services.AddValidatorsFromAssemblyContaining<Authentication_ResponseDTO_Validator>();
            services.AddFluentValidationRulesToSwagger();


            return services;
        }
    }
}