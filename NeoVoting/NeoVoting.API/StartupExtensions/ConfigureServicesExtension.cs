using FluentValidation;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using NeoVoting.Application.Services;
using NeoVoting.Application.ServicesContracts;
using NeoVoting.Domain.Contracts;
using NeoVoting.Domain.IdentityEntities;
using NeoVoting.Domain.RepositoryContracts;
using NeoVoting.Infrastructure.DbContext;
using NeoVoting.Infrastructure.Repositories;
using System.Reflection;
using System.Text;

namespace NeoVoting.API.StartupExtensions
{
    public static class ConfigureServicesExtension
    {
        public static IServiceCollection ConfigureServices(this IServiceCollection services,
            IConfiguration configuration, ConfigureHostBuilder configureHostBuilder)
        {
            // Add services to the container.

            services.AddControllers();

            // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
            services.AddEndpointsApiExplorer();
            



            // =========================================================================
            // SWAGGER CONFIGURATION START
            // =========================================================================
            services.AddSwaggerGen(options =>
            {
                options.SwaggerDoc("v1", new OpenApiInfo
                {
                    Title = "NeoVoting API",
                    Version = "v1",
                    Description = "API for the NeoVoting System"
                });

                // 1. Define the Security Scheme (The "Padlock" definition)
                options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
                {
                    Name = "Authorization",
                    Description = "Enter the JWT token directly. \r\n\r\nExample: `eyJhbGciOiJIUzI1Ni...`",
                    In = ParameterLocation.Header,
                    Type = SecuritySchemeType.Http, // Use Http for standard Bearer auth
                    Scheme = "Bearer",
                    BearerFormat = "JWT"
                });

                // 2. Define the Security Requirement (Apply the lock to endpoints)
                options.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer" // Must match the name defined above
                }
            },
            Array.Empty<string>() // Scopes (leave empty for standard JWT)
        }
    });
            });
            // =========================================================================
            // SWAGGER CONFIGURATION END
            // =========================================================================

            services.AddHttpClient<IGovernmentSystemGateway, GovernmentSystemGateway>(client =>
            {
                var baseUrl = configuration["GovernmentSystem:BaseUrl"]
                              ?? throw new Exception("GovernmentSystem:BaseUrl is missing");

                client.BaseAddress = new Uri(baseUrl);

                var apiKey = configuration["GovernmentSystem:ApiKey"]
                             ?? throw new Exception("GovernmentSystem:ApiKey is missing");

                client.DefaultRequestHeaders.Add("X-Gov-Api-Key", apiKey);
            });

            services.AddIdentity<ApplicationUser, ApplicationRole>(options =>
            {
                options.Password.RequireDigit = false;
                options.Password.RequireLowercase = false;
                options.Password.RequireUppercase = false;
                options.Password.RequireNonAlphanumeric = false; // Set to false if you want to allow only letters and digits
                options.Password.RequiredLength = 6;
                options.Password.RequiredUniqueChars = 1; // You can increase for stricter policy
                options.Lockout.AllowedForNewUsers = true;
                options.Lockout.MaxFailedAccessAttempts = 5;        // ← how many times
                options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(15); // lock duration
            })

                .AddEntityFrameworkStores<ApplicationDbContext>()

                .AddDefaultTokenProviders()


                ;

            // The two lines below are unnecessary. The `.AddEntityFrameworkStores<TContext>()`
            // call you made above ALREADY registers these for you.
            // You are explicitly re-registering the exact same default implementations.
            /*
               .AddUserStore<UserStore
               <ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
               //Repository for Users generated by EF automatically
               .AddRoleStore<RoleStore
               <ApplicationRole, ApplicationDbContext, Guid>>()
               ;
            */



            // Get the connection string from appsettings.json
            var connectionString = configuration.GetConnectionString("DefaultConnection")
                ?? throw new InvalidOperationException
                ("Connection string 'DefaultConnection' not found.");

            services.AddDbContext<ApplicationDbContext>(options =>
            {
                options.UseSqlServer(connectionString);
            });


            // --- REGISTER THE UNIT OF WORK ---
            // We use AddScoped for the lifetime. This means a single instance of UnitOfWork
            // (and therefore ApplicationDbContext) is created for each HTTP request. This is the standard.
            services.AddScoped<IUnitOfWork, UnitOfWork>();

            // --- REGISTER REPOSITORIES ---

            services.AddScoped<ICandidateProfileRepository, CandidateProfileRepository>();
            services.AddScoped<IElectionRepository, ElectionRepository>();
            services.AddScoped<IElectionStatusRepository, ElectionStatusRepository>();
            services.AddScoped<IElectionWinnerRepository, ElectionWinnerRepository>();
            services.AddScoped<IGovernorateRepository, GovernorateRepository>();
            services.AddScoped<IPublicVoteLogRepository, PublicVoteLogRepository>();
            services.AddScoped<ISystemAuditLogRepository, SystemAuditLogRepository>();
            services.AddScoped<IVoteChoiceRepository, VoteChoiceRepository>();
            services.AddScoped<IVoteRepository, VoteRepository>();
          

            //  services.AddValidatorsFromAssembly(Assembly.Load("NeoVoting.Application.Validators"));

            services.AddScoped<IAuthServices, AuthServices>();
            services.AddScoped<ITokenServices, TokenServices>();

            // 2. Configure Authentication
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            })
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = configuration["JwtSettings:Issuer"],
                    ValidAudience = configuration["JwtSettings:Audience"],
                    IssuerSigningKey = new SymmetricSecurityKey(
                        Encoding.UTF8.GetBytes(configuration["JwtSettings:Key"]!))
                };

                options.Events = new JwtBearerEvents
                {
                    // Handle 401 Unauthorized (Token invalid or missing)
                    OnChallenge = async context =>
                    {
                        // Skip the default logic
                        context.HandleResponse();

                        context.Response.StatusCode = StatusCodes.Status401Unauthorized;
                        context.Response.ContentType = "application/problem+json";

                        var problem = new ProblemDetails
                        {
                            Type = "https://tools.ietf.org/html/rfc7235#section-3.1",
                            Title = "Unauthorized",
                            Status = StatusCodes.Status401Unauthorized,
                            Detail = "Authentication failed. Token is missing, invalid, or expired.",
                            Instance = context.Request.Path
                        };

                        await context.Response.WriteAsJsonAsync(problem);
                    },

                    // Handle 403 Forbidden (Token valid, but Role/Policy failed)
                    OnForbidden = async context =>
                    {
                        context.Response.StatusCode = StatusCodes.Status403Forbidden;
                        context.Response.ContentType = "application/problem+json";

                        var problem = new ProblemDetails
                        {
                            Type = "https://tools.ietf.org/html/rfc7231#section-6.5.3",
                            Title = "Forbidden",
                            Status = StatusCodes.Status403Forbidden,
                            Detail = "You do not have permission to access this resource.",
                            Instance = context.Request.Path
                        };

                        await context.Response.WriteAsJsonAsync(problem);
                    }
                };
            });


            return services;
        }
    }
}
