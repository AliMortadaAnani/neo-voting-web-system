using FluentValidation;
using FluentValidation.AspNetCore;
using GovernmentSystem.API.Application.Exceptions;
using GovernmentSystem.API.Application.Services;
using GovernmentSystem.API.Application.ServicesContracts;
using GovernmentSystem.API.Application.Validators;
using GovernmentSystem.API.Domain.Contracts;
using GovernmentSystem.API.Domain.Entities;
using GovernmentSystem.API.Domain.RepositoryContracts;
using GovernmentSystem.API.Infrastructure.DbContext;
using GovernmentSystem.API.Infrastructure.Repositories;
using MicroElements.Swashbuckle.FluentValidation.AspNetCore;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.OpenApi.Models;
using System.Reflection;

namespace GovernmentSystem.API.StartupExtensions
{
    public static class ConfigureServicesExtension
    {
        public static IServiceCollection ConfigureServices(this IServiceCollection services,
            IConfiguration configuration, ConfigureHostBuilder configureHostBuilder)
        {
            // Get the connection string from appsettings.json
            var connectionString = configuration.GetConnectionString("DefaultConnection")
                ?? throw new InvalidOperationException
                ("Connection string 'DefaultConnection' not found.");

            services.AddDbContext<ApplicationDbContext>(options =>
            {
                options.UseSqlServer(connectionString);
            });

            services.AddIdentity<ApplicationUser, ApplicationRole>(options =>
            {
                options.Password.RequireDigit = true;
                options.Password.RequireLowercase = false;
                options.Password.RequireUppercase = false;
                options.Password.RequireNonAlphanumeric = false; // Set to false if you want to allow only letters and digits
                options.Password.RequiredLength = 4;
                options.Password.RequiredUniqueChars = 1; // You can increase for stricter policy
            })
                .AddEntityFrameworkStores<ApplicationDbContext>()
                .AddDefaultTokenProviders()
                ;

            // The two lines below are unnecessary. The `.AddEntityFrameworkStores<TContext>()`
            // call you made above ALREADY registers these for you.
            // You are explicitly re-registering the exact same default implementations.
            /*
               .AddUserStore<UserStore
               <ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
               //Repository for Users generated by EF automatically
               .AddRoleStore<RoleStore
               <ApplicationRole, ApplicationDbContext, Guid>>()
               ;
            */

            /*// 2. Configure the "Most Secure" Cookie Settings
            // ---------------------------------------------------------
            services.ConfigureApplicationCookie(options =>
            {
                // SECURITY 1: HttpOnly
                // Prevents JavaScript (XSS attacks) from reading the cookie.
                options.Cookie.HttpOnly = true;

                // SECURITY 2: Secure Policy
                // Always requires HTTPS. (Browsers reject "Secure" cookies on HTTP).
                // Use 'Always' in Prod. For Localhost, 'SameAsRequest' is easier if you aren't using https locally.
                options.Cookie.SecurePolicy = CookieSecurePolicy.Always;

                // SECURITY 3: SameSite
                // 'Strict': Cookie is only sent if the URL matches exactly. Best for Swagger/API on same domain.
                // 'None': Required later for React (port 3000) talking to API (port 5000).
                // For now (Swagger), we use Strict. When you add React, change to None.
                options.Cookie.SameSite = SameSiteMode.Strict;

                // SECURITY 4: Name Obfuscation
                // Don't call it "IdentityCookie". Hide the tech stack.
                options.Cookie.Name = "__Host-Gov-Auth";

                // API BEHAVIOR:
                // Identity normally redirects to a Login HTML page on failure.
                // We are an API, so we force it to return 401/403 codes instead.
                options.Events.OnRedirectToLogin = context =>
                {
                    context.Response.StatusCode = StatusCodes.Status401Unauthorized;
                    return Task.CompletedTask;
                };
                options.Events.OnRedirectToAccessDenied = context =>
                {
                    context.Response.StatusCode = StatusCodes.Status403Forbidden;
                    return Task.CompletedTask;
                };

                // TIMEOUT
                options.ExpireTimeSpan = TimeSpan.FromMinutes(60);
                options.SlidingExpiration = true; // Extend time if user is active
            });
*/

            // Cookie configuration with ProblemDetails for 401/403
            services.ConfigureApplicationCookie(options =>
            {
                // A. Security Settings
                options.Cookie.HttpOnly = true; // Prevents JavaScript from reading the cookie
                options.Cookie.SecurePolicy = CookieSecurePolicy.Always; // Requires HTTPS
                options.Cookie.SameSite = SameSiteMode.Strict; // strict prevents CSRF
                options.Cookie.Name = "__Host-Gov-Auth";

                options.Events.OnRedirectToLogin = context =>
                {
                    if (IsApiRequest(context.Request))
                    {
                        context.Response.StatusCode = StatusCodes.Status401Unauthorized;
                        context.Response.ContentType = "application/problem+json";

                        var problem = new ProblemDetails
                        {
                            Status = StatusCodes.Status401Unauthorized,
                            Title = "Unauthorized",
                            Detail = "Authentication is required to access this resource.",
                            Type = "https://httpstatuses.com/401"
                        };

                        return context.Response.WriteAsJsonAsync(problem);
                    }

                    // Non-API (if you ever have MVC pages)
                    context.Response.Redirect(context.RedirectUri);
                    return Task.CompletedTask;
                };

                options.Events.OnRedirectToAccessDenied = context =>
                {
                    if (IsApiRequest(context.Request))
                    {
                        context.Response.StatusCode = StatusCodes.Status403Forbidden;
                        context.Response.ContentType = "application/problem+json";

                        var problem = new ProblemDetails
                        {
                            Status = StatusCodes.Status403Forbidden,
                            Title = "Forbidden",
                            Detail = "You do not have permission to access this resource.",
                            Type = "https://httpstatuses.com/403"
                        };

                        return context.Response.WriteAsJsonAsync(problem);
                    }

                    context.Response.Redirect(context.RedirectUri);
                    return Task.CompletedTask;
                };

                options.ExpireTimeSpan = TimeSpan.FromDays(14); // 14 days
                options.SlidingExpiration = true; // optional, for sliding window

                //options.ExpireTimeSpan = TimeSpan.FromMinutes(60);
                //options.SlidingExpiration = true;
            });

            static bool IsApiRequest(HttpRequest request)
            {
                // simple heuristic: all your APIs are under /api
                return request.Path.StartsWithSegments("/api", StringComparison.OrdinalIgnoreCase);
            }

            // 4. Setup CORS (Crucial if your frontend is on a different port, e.g., React/Angular)
            //services.AddCors(options =>
            //{
            //    options.AddPolicy("FrontendPolicy", policy =>
            //    {
            //        policy.WithOrigins("http://localhost:3000") // Your Frontend URL
            //              .AllowAnyMethod()
            //              .AllowAnyHeader()
            //              .AllowCredentials(); // <--- REQUIRED for Cookies to be sent/received
            //    });
            //});

            services.AddControllers();
            services.AddEndpointsApiExplorer();

            // Register your Custom Handler
            services.AddExceptionHandler<GlobalExceptionHandler>();
            services.AddProblemDetails(); // Required for .NET 8 Exception Handler to work

            services.AddSwaggerGen(c =>
            {
                // Standard Swagger metadata
                c.SwaggerDoc("v1", new OpenApiInfo { Title = "Government System API", Version = "v1" });

                // 1. DEFINITION: "Here is a security scheme that exists"
                // This tells Swagger: "I support a security mode called 'ApiKey'.
                // It works by sending a value in the Header named 'X-Gov-Api-Key'."
                c.AddSecurityDefinition("ApiKey", new OpenApiSecurityScheme
                {
                    Description = "Enter your API Key below.",
                    Name = "X-Gov-Api-Key",       // The actual HTTP Header name to send
                    In = ParameterLocation.Header,// Where to put the key (Header, Query, Cookie)
                    Type = SecuritySchemeType.ApiKey, // The type of auth
                    Scheme = "ApiKeyScheme"
                });

                // 2. REQUIREMENT: "Apply this scheme to the endpoints"
                // This tells Swagger: "By default, assume every endpoint might need this lock."
                // When you click 'Authorize' and enter the key, Swagger will send that key
                // with EVERY request you make in the browser.
                c.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id = "ApiKey" // Must match the name defined in AddSecurityDefinition
                            },
                            In = ParameterLocation.Header
                        },
                        new List<string>() // Scopes (used for OAuth, empty for ApiKey)
                    }
                });

                // c.OperationFilter<GlobalResponseFilter>();
                //for productResponsesTypes in controllers

                // 1. Get the name of the generated XML file (usually YourProjectName.xml)
                var xmlFilename = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";

                // 2. Combine with the base directory to get the full path
                var fullPath = Path.Combine(AppContext.BaseDirectory, xmlFilename);

                // 3. Tell Swagger to use it
                c.IncludeXmlComments(fullPath);
            });

            // --- REGISTER THE UNIT OF WORK ---
            // We use AddScoped for the lifetime. This means a single instance of UnitOfWork
            // (and therefore ApplicationDbContext) is created for each HTTP request. This is the standard.
            services.AddScoped<IUnitOfWork, UnitOfWork>();

            // --- REGISTER REPOSITORIES ---

            services.AddScoped<ICandidateRepository, CandidateRepository>();
            services.AddScoped<IVoterRepository, VoterRepository>();
            services.AddScoped<IAdminServices, AdminServices>();
            services.AddScoped<IVoterServices, VoterServices>();
            services.AddScoped<ICandidateServices, CandidateServices>();

            services.AddFluentValidationAutoValidation();
            services.AddValidatorsFromAssemblyContaining<LoginDTOValidator>();
            services.AddFluentValidationRulesToSwagger();

            return services;
        }
    }
}